package com.securboration.miniatakapp.dfus.cipher;

import java.io.IOException;
import java.io.InputStream;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.LinkedBlockingDeque;

/**
 * Unwraps the padded data generated by a
 * {@link com.securboration.miniatakapp.dfus.cipher.DataPaddingOutputStream}
 * 
 * @author jstaples
 *
 */
public class DataPaddingInputStream extends InputStream {
    
    private boolean returnEos = false;
    
    private final int maxBufferSize = 1024*1024;
    private final InputStream delegate;
    
    private final BlockingDeque<Integer> buffer = 
            new LinkedBlockingDeque<>(maxBufferSize);
    
    private final BlockReaderFsm fsm;
    
    public DataPaddingInputStream(
            final int blockSizeBytes, 
            final InputStream delegate
            ) {
        super();
        
        if(blockSizeBytes < 5){
            throw new RuntimeException("block size must be at least 5 bytes");
        }
        
        this.delegate = delegate;
        this.fsm = new BlockReaderFsm(blockSizeBytes,buffer);
        
        Thread reader = new Thread(){
            @Override
            public void run() {
                final byte[] buffer = new byte[blockSizeBytes*4];
                
                while(readerThread(buffer)){;}
            }
        };
        
        reader.setName("block input reader");
        reader.setDaemon(true);
        reader.start();
    }
    
    private static class BlockReaderFsm {
        
        private static final int EOS_VALUE = Integer.MIN_VALUE;
        private static final int ERROR_VALUE = Integer.MAX_VALUE;
        
        private static final int STATE_READ_SIZE_1 = 0;
        private static final int STATE_READ_SIZE_2 = 1;
        private static final int STATE_READ_SIZE_3 = 2;
        private static final int STATE_READ_SIZE_4 = 3;
        
        private static final int STATE_READ_DATA = 10;
        private static final int STATE_READ_PADDING = 20;
        private static final int STATE_EOS = 30;
        
        private int state = STATE_READ_SIZE_1;
        
        private int nextMessageSizeTmp = -1;
        
        private int currentMessageDataSize = -1;
        private int currentBlockDataIndex = -1;
        private int currentMessagePaddingSize = -1;
        private int currentBlockPaddingIndex = -1;
        
        private final BlockingDeque<Integer> buffer;
        
        private final int blockSizeBytes;
        
        private IOException exception = null;
        
        private BlockReaderFsm(
                final int blockSizeBytes,
                final BlockingDeque<Integer> buffer
                ){
            this.buffer = buffer;
            this.blockSizeBytes = blockSizeBytes;
        }
        
        private void debugFsm(String tag){
            if(true){
                return;
            }
            
            System.out.printf(
                "fsm state %s: %d\n" +
                "\tnextMessageSize = %d\n" +
                "\tcurrentMessageSize = %d\n" +
                "\tcurrentBlockDataIndex = %d\n" +
                "\tcurrentMessagePaddingSize = %d\n" +
                "\tcurrentMessagePaddingIndex = %d\n" +
                "\tbuffer size = %d\n" +
                "\tblock size = %d\n" +
                "\texception = %s\n", 
                tag,
                state,
                nextMessageSizeTmp,
                currentMessageDataSize,
                currentBlockDataIndex,
                currentMessagePaddingSize,
                currentBlockPaddingIndex,
                buffer.size(),
                blockSizeBytes,
                exception
                );
        }
        
        private IOException getThrown(){
            synchronized(this){
                return this.exception;
            }
        }
        
        private void error(IOException e){
            synchronized(this){
                this.exception = e;
            }
            
            state = STATE_EOS;
            
            try{
                buffer.put(ERROR_VALUE);
            } catch(InterruptedException ee){
                throw new RuntimeException(ee);
            }
        }
        
        private void fsm(
                final int valueRead
                ) throws InterruptedException, IOException{
            debugFsm("before reading " + valueRead);
            
            final byte b = (byte)valueRead;
            
            if(state == STATE_EOS){
                throw new IOException(
                    "received data " + 
                    String.format(" hex=%02x int=%d", valueRead, valueRead) + 
                    " after EOS marker"
                    );
            } else if(valueRead == EOS_VALUE){
                //EOS-no more bytes to receive
                buffer.put(-1);
                state = STATE_EOS;
            } else if(state == STATE_READ_SIZE_1){
                {//reset all FSM vars
                    nextMessageSizeTmp = -1;
                    
                    currentMessageDataSize = -1;
                    currentBlockDataIndex = -1;
                    currentMessagePaddingSize = -1;
                    currentBlockPaddingIndex = -1;
                }
                
                nextMessageSizeTmp = 0;
                nextMessageSizeTmp |= (b & 0x000000FF) << 24;
                state = STATE_READ_SIZE_2;
            } else if(state == STATE_READ_SIZE_2){
                nextMessageSizeTmp |= (b & 0x000000FF) << 16;
                state = STATE_READ_SIZE_3;
            } else if(state == STATE_READ_SIZE_3){
                nextMessageSizeTmp |= (b & 0x000000FF) << 8;
                state = STATE_READ_SIZE_4;
            } else if(state == STATE_READ_SIZE_4){
                nextMessageSizeTmp |= (b & 0x000000FF) << 0;
                
                currentMessageDataSize = nextMessageSizeTmp;
                
                //determine and set current block padding size
                {
                    currentMessagePaddingSize = 
                            Blockifier.getPaddingBytes(
                                blockSizeBytes, 
                                currentMessageDataSize
                                );
                }
                
                if(currentMessageDataSize > 0){//nonzero data bytes: go to READ_DATA
                    currentBlockDataIndex = 0;
                    state = STATE_READ_DATA;
                } else if(currentMessageDataSize == 0){//zero data to read, weird...
                    
                    if(currentMessagePaddingSize > 0){//nonzero padding: go to READ_PADDING
                        currentBlockPaddingIndex = 0;
                        state = STATE_READ_PADDING;
                    } else if(currentMessagePaddingSize == 0){//also zero padding: go to READ_SIZE_1
                        state = STATE_READ_SIZE_1;
                    } else {//unhandled
                        throw new RuntimeException("unhandled state");
                    }
                }
                else{//unhandled
                    throw new RuntimeException("unhandled state");
                }
            } else if(state == STATE_READ_DATA){
                buffer.put(valueRead);
                currentBlockDataIndex ++;
                
                if(currentBlockDataIndex == currentMessageDataSize){
                    if(currentMessagePaddingSize > 0){//nonzero padding: go to READ_PADDING
                        currentBlockPaddingIndex = 0;
                        state = STATE_READ_PADDING;
                    } else if(currentMessagePaddingSize == 0){//also zero padding: go to READ_SIZE_1
                        state = STATE_READ_SIZE_1;
                    } else {//unhandled
                        throw new RuntimeException("unhandled state");
                    }
                }
            } else if(state == STATE_READ_PADDING){
                currentBlockPaddingIndex++;
                if(currentBlockPaddingIndex == currentMessagePaddingSize){
                    state = STATE_READ_SIZE_1;
                } else {
                    //discard the data
                }
            }
            
            debugFsm("after reading " + valueRead);
        }
        
    }
    
    
    private boolean readerThread(byte[] tempBuffer){
        try {
            final int bytesRead = delegate.read(tempBuffer);
            
            {//may block if the buffer fills
                if(bytesRead == -1){
                    fsm.fsm(BlockReaderFsm.EOS_VALUE);
                    return false;
                } else {
                    for(int i=0;i<bytesRead;i++){
                        fsm.fsm(tempBuffer[i] & 0x000000FF);
                    }
                }
            }//end blocking code region
        } catch(IOException e){
            fsm.error(e);
            return false;
        } catch(InterruptedException e){
            return false;//TODO: not much can be done here
        }
        
        return true;
    }
    
    @Override
    public int read() throws IOException {
        if(returnEos){
            return -1;
        }
        
        try {
            final int value = buffer.take();
            
            if(value == BlockReaderFsm.ERROR_VALUE){
                throw fsm.getThrown();
            }
            
            if(value == -1){
                returnEos = true;
            }
            
            return value;
        } catch (InterruptedException e) {
            throw new IOException(e);
        }
    }

    @Override
    public int read(byte[] b) throws IOException {
        return read(b,0,b.length);
    }

    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        if(returnEos){
            return -1;
        }
        
        try{
            int bytesRead = 0;
            final int length = buffer.size();
            for(int i=0;i<length && i < len;i++){
                final int valueRead = buffer.take();
                
                if(valueRead == -1){
                    returnEos = true;
                    break;
                }
                
                if(valueRead == BlockReaderFsm.ERROR_VALUE){
                    if(fsm.getThrown() == null){
                        throw new RuntimeException("unknown exception");
                    } else {
                        throw fsm.getThrown();
                    }
                }
                
                b[i+off] = (byte)valueRead;
                bytesRead++;
            }
            
            return bytesRead;
        } catch(InterruptedException e){
            throw new IOException(e);
        }
    }

    @Override
    public long skip(long n) throws IOException {
        throw new RuntimeException("not supported");
    }

    @Override
    public int available() throws IOException {
        throw new RuntimeException("not supported");
    }

    @Override
    public void close() throws IOException {
        delegate.close();
    }

    @Override
    public synchronized void mark(int readlimit) {
        throw new RuntimeException("not supported");
    }

    @Override
    public synchronized void reset() throws IOException {
        throw new RuntimeException("not supported");
    }

    @Override
    public boolean markSupported() {
        return false;
    }
    
    

}
