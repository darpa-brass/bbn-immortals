import mil.darpa.immortals.config.ImmortalsConfig

import java.nio.file.Paths

// Make the plugins and repositories (including the local one) available
buildscript {
    def IMMORTALS_REPO = Paths.get(getBuildscript().getSourceFile().parent).resolve('shared/IMMORTALS_REPO').toAbsolutePath()
    repositories {
        mavenCentral()
        maven {
            url IMMORTALS_REPO.toString()
        }
        jcenter()
    }
    dependencies {
        classpath 'mil.darpa.immortals:ImmortalsConfig:+'
        classpath 'mil.darpa.immortals:ImmortalsGradle:+'
        classpath 'com.github.jengelman.gradle.plugins:shadow:2.0.1'
    }
}

// Apply global plugins to all projects
allprojects {
    apply plugin: 'eclipse'
}

// TODO: Remove this once you validate it will not break eclipse.
// Apply the java plugin since it makes project management easier
apply plugin: 'java'

// Get the root repository
def IMMORTALS_ROOT = ImmortalsConfig.instance.globals.immortalsRoot

/**
 * @param exe The executable name to search the path for
 * @return bool
 */
def isInPath(String exe) {
    def result = exec {
        commandLine 'which', exe
        setIgnoreExitValue(true)
    }.exitValue
    return result == 0
}

/**
 * @param var_key The environment variable to check if it has been set
 * @return bool
 */
static def isEnvVarSet(String var_key) {
    return (System.env[var_key] != null)
}

/**
 * Helper method to complain about non-existent executables
 */
def exceptionOnNotExistsInPath(String exe, String requirementDetails, String downloadUrl) {
    if (!isInPath(exe)) {
        throw new GradleException("Cannot complete requested operation since executable '${exe}' needed for ${requirementDetails} is not in the path! Please see harness/README-setup.md or ${downloadUrl} to download!")
    }
}

/**
 * Helper method to complain about unset environment variables
 */
static def exceptionOnEnvVarUnset(String var_key, String requirementDetails, String downloadUrl) {
    if (!isEnvVarSet(var_key)) {
        throw new GradleException("Cannot complete requested operation since environment variable '${var_key}' needed for ${requirementDetails} is defined! Please see harness/README-setup.md or ${downloadUrl} to download!")
    }
}

def buildKnowledgeRepo = task('buildKnowledgeRepo', type: Exec) {
    group = 'IMMoRTALS Deploy'
    description = 'Builds the knowledge repository war file'
    workingDir = IMMORTALS_ROOT.resolve('knowledge-repo').toString()
    executable = 'mvn'
    args = ['-DskipTests', 'install']
}

// Various tasks to provide build/clean functionality of external projects
def dslSetup = task('dslSetup', type: Exec) {
    workingDir = IMMORTALS_ROOT.resolve('dsl/resource-dsl').toString()
    executable = 'stack'
    args = ['setup']
}

def dslBuild = task('dslBuild', type: Exec) {
    workingDir = IMMORTALS_ROOT.resolve('dsl/resource-dsl').toString()
    executable = 'stack'
    args = ['build']
}.dependsOn(dslSetup)

def dslClean = task('dslClean', type: Exec) {
    workingDir = IMMORTALS_ROOT.resolve('dsl/resource-dsl').toString()
    executable = 'stack'
    args = ['clean']
}.dependsOn(dslSetup)

def publish = task('publish') {
    subprojects.each {
        it.afterEvaluate {
            // Collect all publish tasks
            if (it.tasks.findByName('publish')) {
                dependsOn("${it.path}:publish")
            }
        }
    }

    afterEvaluate {
        finalizedBy(buildPublishClitak)
    }
}

def buildPublishClitak = task('buildPublishClitak', type: GradleBuild) {
    buildFile = "${rootDir}/applications/client/CLITAK/build.gradle"
    tasks = ['build', 'publish']
    dependsOn(publish)
}

def buildMarti = task('buildMarti', type: GradleBuild) {
    buildFile = "${rootDir}/applications/server/Marti/build.gradle"
    dir = "${rootDir}/applications/server/Marti/"
    tasks = ['build']
    dependsOn(publish, buildPublishClitak)
}

def buildAtakLite = task('buildAtakLite', type: GradleBuild) {
    buildFile = "${rootDir}/applications/client/ATAKLite/build.gradle"
    dir = "${rootDir}/applications/client/ATAKLite/"
    tasks = ['build']
    dependsOn(publish)
}

// TODO: This should probably be part of the ImmortalsServiceManifest "deploy" method and "setupExtensions"...
def setupdb = task('setupdb', type: Exec) {
    group = "IMMoRTALS Deploy"
    description = "Sets up the files for the database and then installs the immortals schema"

    afterEvaluate {
        doFirst {
            exceptionOnNotExistsInPath('psql', 'databases', 'https://www.postgresql.org/')
        }
    }
    workingDir = IMMORTALS_ROOT.resolve('database/server/').toString()
    commandLine = ['bash', 'setup.sh', '--unattended']
}

def buildknowledge = task('buildknowledge', type: Exec) {
    group = "IMMoRTALS Deploy"
    description = "Executes the DAS analysis task to perform analysis that can be done prior to execution"
    workingDir = IMMORTALS_ROOT.resolve('das/das-service/').toString()
    commandLine = ['java', '-jar', 'das.jar', '--analyze']

    dependsOn(setupdb)
}

// TODO: Make this a task definition once you remove applying java
build {
    group = 'IMMoRTALS'
    afterEvaluate {
        doFirst {
            exceptionOnNotExistsInPath('mvn', 'everything', 'https://maven.apache.org/')
        }

        if (System.env['ANDROID_HOME'] == null) {
            finalizedBy(
                    buildPublishClitak,
                    buildMarti,
                    task('printBuildDetails') {
                        doLast {
                            if (!isEnvVarSet('ANDROID_HOME')) {
                                System.err.println('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
                                System.err.println('ATAKLite was not built due to ANDROID_HOME not being set to an android SDK!')
                                System.err.println('If you need to use ATAKLite please see harness/README-setup.md or')
                                System.err.println('https://developer.android.com/studio/releases/platform-tools.html.')
                                System.err.println('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
                            }
                        }

                    }
            )
        } else {
            finalizedBy(buildPublishClitak, buildMarti, buildAtakLite)
        }

        subprojects.each {
            it.afterEvaluate {
                if (it.tasks.findByName('build')) {
                    dependsOn("${it.path}:build")
                }
            }
        }
    }
}

afterEvaluate {
    clean.group = "IMMoRTALS"
}

/**
 * The deploy task.
 */
def deploy = task('deploy') {
    group = 'IMMoRTALS'
    description = 'Executes the full build and all deploy tasks required to deploy an operational system.'

    afterEvaluate {
        doFirst {
//            exceptionOnNotExistsInPath('stack', 'compiling DSL', 'https://www.haskellstack.org')
//            exceptionOnNotExistsInPath('z3', 'compiling DSL', 'https://github.com/Z3Prover/z3')
            exceptionOnEnvVarUnset('ANDROID_HOME', 'ATAKLite', 'https://developer.android.com/studio/releases/platform-tools.html')
        }

    }

    dependsOn(build)
    finalizedBy(buildKnowledgeRepo, setupdb, ':extensions:deploy', buildknowledge)
}

def redeploy = task('redeploy') {
    group = 'IMMoRTALS'
    description = 'Executes the full build and all deploy tasks that should be performed after a clean'

    afterEvaluate {
        doFirst {
//            exceptionOnNotExistsInPath('stack', 'compiling DSL', 'https://www.haskellstack.org')
//            exceptionOnNotExistsInPath('z3', 'compiling DSL', 'https://github.com/Z3Prover/z3')
            exceptionOnEnvVarUnset('ANDROID_HOME', 'ATAKLite', 'https://developer.android.com/studio/releases/platform-tools.html')
        }

    }

    dependsOn(build)
    finalizedBy(buildKnowledgeRepo, ':extensions:deploy', buildknowledge)
}
