package com.securboration.immortals.maven.ontology;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Pattern;

import org.apache.commons.io.FileUtils;
import org.apache.jena.datatypes.xsd.XSDDatatype;
import org.apache.jena.ontology.DataRange;
import org.apache.jena.ontology.OntModel;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.rdf.model.ModelFactory;
import org.apache.jena.rdf.model.Property;
import org.apache.jena.rdf.model.RDFList;
import org.apache.jena.rdf.model.RDFNode;
import org.apache.jena.rdf.model.Resource;
import org.apache.jena.rdf.model.Statement;
import org.apache.jena.rdf.model.StmtIterator;
import org.apache.jena.vocabulary.OWL;
import org.apache.jena.vocabulary.RDF;
import org.apache.jena.vocabulary.RDFS;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.securboration.immortals.maven.PluginContext;
import com.securboration.immortals.maven.etc.ExceptionWrapper;

/**
 * Simple utility class for reading/writing semantic models
 * 
 * @author jstaples
 *
 */
public class OntologyHelper {
    private static Logger logger = LoggerFactory
            .getLogger(OntologyHelper.class);

    /**
     * Serializes the provided model to the provided language
     * 
     * @param m
     *            a model to serialize
     * @param outputLanguage
     *            a language to serialize to (e.g., RDF/XML)
     * @return the serialized model
     * @throws IOException
     */
    public static String serializeModel(Model m, String outputLanguage)
            throws IOException {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        m.write(output, outputLanguage);

        return new String(output.toByteArray());
    }

    /**
     * Loads a non-inferencing model from an input stream
     * 
     * @param input
     *            the stream to read from
     * @param inputLanguage
     *            the language to read from the stream
     * @return the model read
     * @throws IOException
     */
    public static Model loadModel(final InputStream input,
            final String inputLanguage) throws IOException {
        Model model = ModelFactory.createDefaultModel();
        model.read(input, inputLanguage);

        return model;
    }

    /**
     * Prints a vaguely human readable representation of triples in the provided
     * model to the provided printstream
     * 
     * @param model
     *            the model whose triples we will print
     * @param p
     *            where to print
     */
    public static void printTriples(Model model, PrintStream p) {
        StmtIterator statements = model.listStatements();

        int count = 0;
        while (statements.hasNext()) {
            Statement s = statements.next();

            p.printf("%07d: [%s] [%s] [%s]\n", count, s.getSubject(),
                    s.getPredicate(), s.getObject());

            count++;
        }
    }
    
    
    
    public static void addMetadata(
            PluginContext context,
            Model m,
            final String namespace
            ){
        
        Resource r = m.getResource(namespace.replace("#", ""));
        
        r.addLiteral(
                OWL.versionInfo, 
                context.getVersion());
        
        r.addLiteral(
                RDFS.comment, 
                "Automatically generated by the POJO-to-triples Maven plugin, Securboration Inc.");
        
        r.addProperty(RDF.type, OWL.Ontology);
    }
    
    private static Set<String> getLongNames(Map<String,String> namespaceMappings){
        
        Set<String> longNames = new HashSet<>();
        
        for(String s:namespaceMappings.keySet()){
            
            longNames.add(s.substring(0, s.length()-1));
        }
        
        return longNames;
    }
    
    private static void addUri(Resource r,Collection<String> uris){
        if(r.isAnon()){
            return;
        }
        
        if(r.isLiteral()){
            return;
        }
        
        uris.add(r.getURI());
    }
    
    private static void addUri(RDFNode r,Collection<String> uris){
        if(r.isAnon()){
            return;
        }
        
        if(r.isLiteral()){
            return;
        }
        
        addUri(r.asResource(),uris);
    }
    
    private static Set<String> getUris(Model model){
        Set<String> uris = new HashSet<>();
        
        Iterator<Statement> statements = model.listStatements();
        while(statements.hasNext()){
            Statement s = statements.next();
            
            addUri(s.getSubject(),uris);
            addUri(s.getPredicate(),uris);
            addUri(s.getObject(),uris);
        }
        
        return uris;
    }
    
    private static boolean isArrayType(String className){
        return Type.getType(className).getSort() == Type.ARRAY;
    }
    
    private static Property getPropertyForType(PluginContext context,Model model,Type t,String fieldName){
        
        fieldName = fieldName.substring(0,1).toUpperCase() + fieldName.substring(1);
        
        if(t.getSort() == Type.METHOD){
            throw new RuntimeException("not expecting a method desc but found " + t.getDescriptor());
        }
        
        String className = t.getClassName();
        
        if(className.contains(".")){
            className = className.substring(className.lastIndexOf(".")+1);
        }
        
        className = className.replace("[]","Array");
        
//        String classTag = new String(Base64.encode(className.getBytes()));
        
        return model.createProperty(context.getTargetNamespace()+"#has"+fieldName+"_"+className);
    }
    
    public static Property getPropertyForField(PluginContext context, Model model, String fieldName, Type fieldType){
        return getPropertyForType(context,model,fieldType,fieldName);
    }
    
    private static String getFieldComments(File f, String className, FieldNode field){
        
        StringBuilder sb = new StringBuilder();
        ExceptionWrapper.wrap(()->{
            final String content = FileUtils.readFileToString(f);
            String[] parts = content.split("class " + OntologyHelper.getSimpleName(className));
            
            String body = content;
            
//            System.out.printf("body= %s\n", body);
            
            //TODO: utter hack
            String pattern = 
                    Pattern.quote(
                            OntologyHelper.getSimpleName(Type.getType(field.desc).getClassName() + " " + field.name + ";"));
            Pattern p = 
//                    Pattern.compile("(static|private|public|transient|volatile| )*"+pattern);
                    Pattern.compile(pattern);
            
            String[] fieldSplits = p.split(body);
           
            Stack<String> stack = new Stack<>();
            String[] bodyLines = fieldSplits[0].split("\\r?\\n");
            boolean stop = false;
            for(int i=0;i<bodyLines.length && !stop;i++){
                String line = bodyLines[bodyLines.length-1-i];
                
                line = line.trim();
                
                if(line.matches("^(static|private|public|transient|volatile)")){
                    continue;
                }
                if (line.startsWith("/*")) {
                    stop = true;
                } 
//                else if (line.startsWith("*/")) {
//                    stop = true;
//                }
                
//                if(line.isEmpty())
//                {
//                    stop = true;
//                }
                
                stack.push(line);
            }
            
            while(!stack.isEmpty())
            {
                sb.append(stack.pop());
            }
        });
        
        sb.append("\n@creationTimestamp ");
        sb.append(new SimpleDateFormat("yyyy.MM.dd 'at' HH:mm:ss z").format(new Date(f.lastModified())));
        
        String comment = sb.toString().replace("//", "").replace("/**","").replace("*/","").replace("*", "").replace("@author Securboration", "\n@author jstaples");
        
//        System.out.printf("found class comment %s\n", comment);
        
        return comment;
        
    }
    
    private static boolean isPrimitive(Map<Type,Resource> mappings,Type t){
        
        if(mappings.containsKey(t)){
            return true;
        }
        
        if(t.getSort() == Type.OBJECT){
            return false;
        }
        
        if(t.getSort() == Type.ARRAY){
            return false;
        }
        
        return true;
    }
    
    private static boolean isEnum(PluginContext context,Type t) {
        
        if(t.getSort() == Type.ARRAY){
            return false;
        }
        
        return getClass(context,t).isEnum();
    }
    
    private static Class<?> getClass(PluginContext context,Type t){
        try{
            final String className = t.getClassName().replace("/", ".");
            
            Class<?> c = context.getBuildPathClassloader().loadClass(className);
            
            return c;
        } catch(ClassNotFoundException e){
            throw new RuntimeException(e);
        }
    }
    
    private static DataRange getRange(PluginContext context, OntModel model, Type t){
        
        Class<?> enumeration = getClass(context,t);
        
        RDFList list = model.createList();
        for (Object o:enumeration.getEnumConstants()) {
            Enum<?> e = (Enum<?>)o;

            list = list.cons(model.createTypedLiteral(e.name()));
        }
        
        return model.createDataRange(list);
    }
    
    private static RDFNode analyzeType(PluginContext context, OntModel model, Type t){
        
        System.out.printf("analyzing type %s\n", t.getClassName());//TODO
        
        Map<Type,Resource> mappings = OntologyHelper.getTypeMappings(model);
        
        Resource r = mappings.get(t);
        
        if(r != null){
            return r;
        }
        
        if(t.getSort()==Type.METHOD){
            throw new RuntimeException("wasnt expecting a method type here");
        } else if(t.getSort()==Type.ARRAY){
            //create an array wrapper
            
            Resource arrayResource = getResourceForType(context,model,t.getClassName());
            arrayResource.addProperty(RDFS.subClassOf,getResourceForType(context,model,"Array"));
            
            Property p = 
                    model.createProperty(context.getTargetNamespace()+"#hasElement");
//                    model.createProperty(context.getTargetNamespace()+"#has" + OntologyHelper.getSimpleName(t.getElementType().getClassName()) + "Element");
            
            if(isPrimitive(mappings,t.getElementType())){
                p.addProperty(RDF.type, OWL.DatatypeProperty);
            } else {
                p.addProperty(RDF.type, OWL.ObjectProperty);
            }
            
            Type elementType = t.getElementType();
            
            if(t.getDimensions() > 1){
                elementType = Type.getType(t.getInternalName().substring(1));
            }
            
            System.out.printf(
                    "about to analyze element type %s from %s\n", 
                    elementType.getClassName(),
                    t.getClassName());//TODO
            
            p.addProperty(RDFS.range, analyzeType(context,model,elementType));
            p.addProperty(RDFS.domain, arrayResource);
            
            return arrayResource;
            
        } else if(t.getSort()==Type.OBJECT){
            
            if(isEnum(context,t)){
                return getRange(context,model,t);
            }
            
            return OntologyHelper.getResourceForType(context,model,t.getClassName());
        }
        
        throw new RuntimeException("unhandled corner case: " + t.getClassName());
    }
    
    public static Property getPropertyForField(PluginContext context, OntModel model,Resource ownerClass,ClassNode cn,FieldNode field){
        Map<Type,Resource> mappings = OntologyHelper.getTypeMappings(model);
        
        Type t = Type.getType(field.desc);
        
        RDFNode classResource = analyzeType(context,model,t);
        
        Property p = getPropertyForField(context,model,field.name,Type.getType(field.desc));
        
        if(isPrimitive(mappings,t)){
            p.addProperty(RDF.type, OWL.DatatypeProperty);
        } else if(isEnum(context,t)){
            p.addProperty(RDF.type, OWL.DatatypeProperty);
        } else {
            p.addProperty(RDF.type, OWL.ObjectProperty);
        }
        p.addProperty(RDFS.range, classResource);
        p.addProperty(RDFS.domain, ownerClass);
        
        {
            File f = OntologyHelper.getFileForClass(context,cn.name);
            if(f != null){
                String comment = getFieldComments(f,cn.name,field);
                
                p.addLiteral(RDFS.comment, comment);
            }
        }
        
        return p;
    }
    
    private static File getFileForClass(PluginContext context,String className){
        
        String classResource = className.replace(".", "/") + ".java";
        
        for(String root:context.getProject().getCompileSourceRoots())
        {
            final String path = root + "/" + classResource;
            
            File f = new File(path);
            
            if(f.exists()){
                return f;
            }
        }
        
        context.getLog().warn("could not find " + className + " on roots " + context.getProject().getCompileSourceRoots());
        
        return null;
    }
    
    private static String getSimpleName(String className){
        className = className.replace(".", "/");
        String[] parts = className.split("/");
        
        return parts[parts.length-1];
    }
    
    private static String getClassComments(PluginContext context,File f, String className){
        
        StringBuilder sb = new StringBuilder();
        ExceptionWrapper.wrap(()->{
            final String content = FileUtils.readFileToString(f);
            String[] parts = content.split("class " + getSimpleName(className));
            
            String[] headerLines = parts[0].split("\\r?\\n");
            for(String line:headerLines){
                line = line.trim();
                if(line.startsWith("/*") || line.startsWith("*")){
                    sb.append(line);
                }
            }
        });
        
        sb.append("\n@creationTimestamp ");
        sb.append(new SimpleDateFormat("yyyy.MM.dd 'at' HH:mm:ss z").format(new Date(f.lastModified())));
        
        String comment = sb.toString().replace("/**","").replace("*/","").replace("*", "").replace("@author Securboration", "\n@author jstaples");
        
//        System.out.printf("found class comment %s\n", comment);
        
        return comment;
        
    }
    
    public static Resource getResourceForType(
            PluginContext context,
            OntModel model,
            String className
            ){
        
//      System.out.printf("getting resource for type %s\n", className);
      
      final String uri = OntologyHelper.makeUriName(context, className);
      
      Resource resource = model.createClass(uri);
      
      File f = getFileForClass(context,className);
      if(f != null){
          String comment = getClassComments(context,f,className);
          
          resource.addLiteral(RDFS.comment, comment);
      }
      
      return resource;
  }
    
    public static Map<Type,Resource> getTypeMappings(Model model){
        Map<Type,Resource> map = new HashMap<>();
        
        //primitive types
        map.put(
                Type.BOOLEAN_TYPE, 
                model.getResource(XSDDatatype.XSDboolean.getURI()));
        map.put(
                Type.getType(Boolean.class), 
                model.getResource(XSDDatatype.XSDboolean.getURI()));
        
        map.put(
                Type.CHAR_TYPE, 
                model.getResource(XSDDatatype.XSDunsignedByte.getURI()));
        map.put(
                Type.getType(Character.class), 
                model.getResource(XSDDatatype.XSDunsignedByte.getURI()));
        
        map.put(
                Type.DOUBLE_TYPE, 
                model.getResource(XSDDatatype.XSDdouble.getURI()));
        map.put(
                Type.getType(Double.class), 
                model.getResource(XSDDatatype.XSDunsignedByte.getURI()));
        
        map.put(
                Type.FLOAT_TYPE, 
                model.getResource(XSDDatatype.XSDfloat.getURI()));
        map.put(
                Type.getType(Float.class), 
                model.getResource(XSDDatatype.XSDunsignedByte.getURI()));
        
        map.put(
                Type.INT_TYPE, 
                model.getResource(XSDDatatype.XSDint.getURI()));
        map.put(
                Type.getType(Integer.class), 
                model.getResource(XSDDatatype.XSDunsignedByte.getURI()));
        
        map.put(
                Type.LONG_TYPE, 
                model.getResource(XSDDatatype.XSDlong.getURI()));
        map.put(
                Type.getType(Long.class), 
                model.getResource(XSDDatatype.XSDunsignedByte.getURI()));
        
        map.put(
                Type.SHORT_TYPE, 
                model.getResource(XSDDatatype.XSDshort.getURI()));
        map.put(
                Type.getType(Short.class), 
                model.getResource(XSDDatatype.XSDunsignedByte.getURI()));
        
        map.put(
                Type.BYTE_TYPE, 
                model.getResource(XSDDatatype.XSDbyte.getURI()));
        map.put(
                Type.getType(Byte.class), 
                model.getResource(XSDDatatype.XSDunsignedByte.getURI()));
        
        //non primitive types
        map.put(
                Type.getType(String.class), 
                model.getResource(XSDDatatype.XSDstring.getURI()));
        map.put(
                Type.getType(byte[].class), 
                model.getResource(XSDDatatype.XSDbase64Binary.getURI()));
        map.put(
                Type.getType(Date.class), 
                model.getResource(XSDDatatype.XSDdate.getURI()));
        map.put(
                Type.getType(Calendar.class), 
                model.getResource(XSDDatatype.XSDdateTime.getURI()));
        
        
        return map;
    }
    
    private static String makeUriName(PluginContext context,String className){
        
        className = className.replace(".", "/");
        
        Type type = Type.getType(className);
        
        if(isArrayType(className)){
            type = type.getElementType();
        }
        
        for(String trimPrefix:context.getTrimPrefixes()){
            className = className.replace(trimPrefix, "");
        }
        
        className = className.replace(".", "/").replace("[]", "Array");
        
        StringBuilder sb = new StringBuilder();
        sb.append(context.getTargetNamespace());
        
        String[] pieces = className.split("/");
        
        if(!className.startsWith("/") && pieces.length > 1){
            sb.append("/");
        }
        for(int i=0;i<pieces.length-1;i++){
            sb.append(pieces[i]);
            
            if(i<pieces.length-2){
                sb.append("/");
            }
        }
        
        sb.append("#");
        
        sb.append(pieces[pieces.length-1]);
        
        return sb.toString();
    }
    
    
    public static void setNamespacePrefixes(PluginContext context,Model model){
        
        Map<String,String> namespaceMappings = 
                getNamespaceMappings(context);
        
        for(String longName:namespaceMappings.keySet()){
            String shortName = namespaceMappings.get(longName);
            
            model.setNsPrefix(shortName, longName);
        }
        
        if(!context.isAutoGenerateAdditionalPrefixes()){
            return;
        }
        
        Set<String> longNames = getLongNames(namespaceMappings);
        Set<String> uris = getUris(model);
        
        Map<String,String> derivedMappings = new HashMap<>();
        
        for(String uri:uris){
            
            String match = null;
            for(String longName:longNames){
                
                if(uri.startsWith(longName)){
                    if(match == null || longName.length() > match.length()){
                        match = longName;
                    }
                }
            }
            
            if(match != null){
                
                if(!uri.contains("#")){
                    continue;
                }
                
                String temp = uri;
                temp = temp.replace(match, "");
                
                String[] parts = temp.split("#");
                
                if(parts.length != 2){
                    throw new RuntimeException("expected one # character in string " + temp);
                }
                
                String packageRemainder = parts[0];
                
                if(packageRemainder.isEmpty()){
                    continue;
                }
                
                if(packageRemainder.startsWith("/")){
                    packageRemainder = packageRemainder.substring(1);
                }

                final String oldLongName = match+"#";
                final String oldShortName = namespaceMappings.get(oldLongName);
                final String newShortName = oldShortName+"_"+packageRemainder.replace("/", "_");
                final String newLongName = match+"/"+packageRemainder+"#";
                
//                System.out.printf("%s -> %s\n\t%s -> %s\n", oldLongName, oldShortName, newLongName, newShortName);
                
                derivedMappings.put(newLongName, newShortName);
            }
        }
        
        for(String longName:derivedMappings.keySet()){
            String shortName = derivedMappings.get(longName);
            
            model.setNsPrefix(shortName, longName);
        }
    }
    
    private static Map<String,String> getNamespaceMappings(PluginContext pluginContext){
        Map<String,String> namespaceMappings = new HashMap<>();
        
        for(String mapping:pluginContext.getNamespaceMappings()){
            
            String[] parts = mapping.split(" ");
            
            if (parts.length != 2) {
                pluginContext.getLog().warn("Namespace mapping should be a space separated pair of strings mapping a uri prefix to a short prefix.  Instead, got " + mapping + " (this will be ignored)");
                continue;
            }
            
            namespaceMappings.put(parts[0], parts[1]);
        }
        
        return namespaceMappings;
    }
}